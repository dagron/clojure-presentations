<html>

<head>
	
	<title>clojure concurrency</title>

<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<!-- style sheet links -->
<link rel="stylesheet" href="clojure-concurrency.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="s6/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="s6/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="s6/code-highlighter.css" type="text/css"/>

<!-- S6 JS -->
<script src="s6/jquery.js" type="text/javascript"></script>
<script src="s6/slides.js" type="text/javascript"></script>
<script src="s6/code-highlighter.js" type="text/javascript"></script>
<script src="s6/clojure.js" type="text/javascript"></script>
<script src="s6/javascript.js" type="text/javascript"></script>
<script src="s6/ruby.js" type="text/javascript"></script>

</head>
<body>

<div class="layout">
  
  <div class="background">  
<!--     <object data="clojure-concurrency.svg" width="100%" height="100%"> -->
<!-- 		</object> -->
  </div>   
  
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1></h1>
<h2></h2>
</div>

      <div id='microsoft'>       
        <p>
          Microsoft's Internet Explorer browser
            has no built-in vector graphics machinery
             required for "loss-free" gradient background themes.
        </p>        
        <p>
          Please upgrade to a better browser
           such as <a href='http://getfirefox.com'>Firefox</a>, <a href='http://www.opera.com/download'>Opera</a>,
            <a href='http://apple.com/safari/download'>Safari</a> or others
            with built-in vector graphics machinery and much more.
          
          (Learn more or post questions or comments
              at the <a href='http://slideshow.rubyforge.org'>Slide Show (S9)</a>
            project site. Thanks!)
        </p>             
    </div>
</div>

<div class="presentation">
<div class='slide'>

<h1>clojure concurrency</h1>
<ul>
	<li>stuart halloway</li>
	<li>stu@thinkrelevance.com</li>
	<li>http://github.com/stuarthalloway/clojure-presentations</li>
</ul>


</div><div class='slide'>

<h1 class="center">a tale of 5 concurrency models</h1>


</div><div class='slide'>

<h1 class="center">1. refs</h1>


</div><div class='slide'>

<h1 class="center">2. atoms</h1>


</div><div class='slide'>

<h1 class="center">3. agents</h1>


</div><div class='slide'>

<h1 class="center">4. dynamic vars</h1>


</div><div class='slide'>

<h1 class="center">5. locking</h1>


</div><div class='slide'>

<h1 class="center">game break!</h1>


</div><div class='slide'>

<h1 class="center">1. references</h1>


</div><div class='slide'>

<h1>ref and deref</h1>
<pre>
<code class="clojure">(def current-track (ref "Mars, the Bringer of War"))
-&gt; #'user/current-track   

current-track
-&gt; #&lt;Ref clojure.lang.Ref@6fe2479&gt;    

(deref current-track)
-&gt; "Mars, the Bringer of War"

@current-track
-&gt; "Mars, the Bringer of War"    
</code>
</pre>


</div><div class='slide'>

<h1>updates require a transaction</h1>
<pre>
<code class="clojure">(ref-set current-track "Venus, the Bringer of Peace")
-&gt; java.lang.IllegalStateException: No transaction running 
</code>
</pre>


</div><div class='slide'>

<h1>dosync scopes a transaction</h1>
<pre> 
<code class="clojure">(dosync (ref-set current-track "Venus, the Bringer of Peace"))
"Venus, the Bringer of Peace"    
</code>
</pre>


</div><div class='slide'>

<h1 class="center">alter</h1>

<pre>
<code class="clojure">clojure.core/alter
([ref fun &amp; args])
  Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.
</code>
</pre>


</div><div class='slide'>

<h1>alter example</h1>
<pre>
<code class="clojure">(defstruct message :sender :text)
(def messages (ref ()))

(defn add-message [msg]
  (dosync (alter messages conj msg)))
</code>
</pre>


</div><div class='slide'>

<h1>ACID properties</h1>
<ul>
	<li>atomic</li>
	<li>consistent</li>
	<li>isolated</li>
	<li>durable</li>
</ul>


</div><div class='slide'>

<h1 class="center">clojure STM provides ACI (not D)</h1>


</div><div class='slide'>

<h1>consistency via validators</h1>
<pre>
<code class="clojure">(defn validate-message-list [lst]
  (if (not-every? #(and (:sender %) (:text %)) lst)
    (throw (IllegalStateException. "Not a valid message"))
    true))

(def messages (ref () :validator validate-message-list))
</code>
</pre>


</div><div class='slide'>

<h1>atomicity and isolation</h1>
<ul>
	<li>(MVCC) multiversion concurrency control</li>
</ul>


</div><div class='slide'>

<h1>how MVCC works</h1>
<ul>
	<li>tx begins by taking a <strong>point</strong></li>
	<li>tx works against in-transaction-value</li>
	<li>if another (post-point) tx write collides, retry</li>
	<li>tx commit takes another point</li>
</ul>


</div><div class='slide'>

<h1>ref-set and alter cause collisions</h1>
<ul>
	<li>what if you don&#8217;t care about collisions?</li>
	<li>your update must be <strong>commutative</strong></li>
	<li>use <code>commute</code> instead</li>
</ul>


</div><div class='slide'>

<h1>commute example</h1>
<pre>
<code class="clojure">(defn add-message-commute [msg]
  (dosync (commute messages conj msg)))
</code>
</pre>


</div><div class='slide'>

<h1>prefer alter</h1>
<ul>
	<li><code>commute</code> is an optimization</li>
	<li><code>alter</code> will always work in place of <code>commute</code></li>
	<li>the reverse is <strong>not</strong> true!</li>
</ul>


</div><div class='slide'>

<h1 class="center">2. atoms</h1>


</div><div class='slide'>

<h1>why atoms?</h1>
<ul>
	<li>refs imply coordination</li>
	<li>or the possibility of future coordination</li>
	<li>what if you have just one bit of state?</li>
</ul>


</div><div class='slide'>

<h1>atom api parallels ref api</h1>
<table>
<thead>
    <th>function</th>
    <th>ref api</th>
    <th>atom api</th>
</thead>
<tr>
    <td>create</td>
    <td><code>ref</code></td>
    <td><code>atom</code></td>
</tr>
<tr>
    <td>deref</td>
    <td><code>deref</code>/<code>@</code></td>
    <td><code>deref</code>/<code>@</code></td>
</tr>
<tr>
    <td>update</td>
    <td><code>alter</code></td>
    <td><code>swap!</code></td>
</tr>
<tr>
    <td>set</td>
    <td><code>ref-set</code></td>
    <td><code>reset!</code></td>
</tr>
</table>


</div><div class='slide'>

<h1>atom example</h1>
<pre>
<code class="clojure">; from clojure core
(defn memoize
  [f]
  (let [mem (atom {})]
    (fn [&amp; args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
</code>
</pre>


</div><div class='slide'>

<h1 class="center">3. agents</h1>


</div><div class='slide'>

<h1>Why agents</h1>
<ul>
	<li>refs provide coordinated synchronous updates</li>
	<li>atoms provide uncoordinated synchronous updates</li>
	<li>agents provide <strong>asynchronous</strong> updates</li>
</ul>


</div><div class='slide'>

<h1 class="center">unified update model</h1>


</div><div class='slide'>

<h1>update functions</h1>
<table>
<thead>
    <th>Update Mechanism</th>
    <th>Refs</th>
    <th>Atoms</th>
    <th>Agents</th>
</thead>
<tr>
    <td>pure function application</td>
    <td><code>alter</code></td>
    <td><code>swap!</code></td>
    <td><code>send</code></td>
</tr>
<tr>
    <td>pure function (commutative)</td>
    <td><code>commute</code></td>
    <td>N/A</td>
    <td>N/A</td>
</tr>
<tr>
    <td>pure function (blocking)</td>
    <td>N/A</td>
    <td>N/A</td>
    <td><code>send-off</code></td>
</tr>
<tr>
    <td>setter</td>
    <td><code>ref-set</code></td>
    <td><code>reset!</code></td>
    <td>N/A</td>
</tr>
</table>


</div><div class='slide'>

<h1>agent example</h1>
<pre>
<code class="clojure">(defn add-message-with-backup [msg]
  (dosync 
   (let [snapshot (commute messages conj msg)]
     (send-off backup-agent (fn [filename]
			      (spit filename snapshot)
			      filename))
     snapshot)))
</code>
</pre>


</div><div class='slide'>

<h1 class="center">4. dynamic vars</h1>


</div><div class='slide'>

<h1>vars can be set and dynamically bound</h1>
<ul>
	<li>use <code>set</code> for control flags</li>
	<li>use <code>binding</code> to make a temporary change</li>
	<li>name vars intended for binding like `<strong>out</strong>`</li>
</ul>


</div><div class='slide'>

<h1>set/binding example</h1>
<pre>
<code class="clojure">(set! *print-length* 5)
-&gt; 5

(range 20)
-&gt; (0 1 2 3 4 ...)

(binding [*print-length* 10] (range 20))
-&gt; (0 1 2 3 4 ...)

(binding [*print-length* 10] (pr (range 20)))
-&gt; (0 1 2 3 4 5 6 7 8 9 ...)
</code>
</pre>


</div><div class='slide'>

<h1>binding example</h1>
<pre>
<code class="clojure">(use 'clojure.contrib.shell-out)
(def foo
  (with-out-str
    (println [1 2 3])
    (println #{:A :B :C})))

(print foo)
[1 2 3]
#{:A :B :C}  
</code>
</pre>


</div><div class='slide'>

<h1 class="center">5. locking</h1>


</div><div class='slide'>

<h1>locking example</h1>
<pre>
<code class="clojure">; from lancet
(defn runonce
  [function] 
  (let [sentinel (Object.)
	result (atom sentinel)
	reset-fn (fn [] (reset! result sentinel))
	has-run-fn (fn [] (not= @result sentinel))]
    [has-run-fn
     reset-fn
     (fn [&amp; args]
       (locking sentinel
	 (if (= @result sentinel)
	   (reset! result (function))
	   @result)))]))
</code>
</pre>


</div><div class='slide'>

<h1 class="center" style="font-size: 30pt;"><a href="http://www.pragprog.com/titles/shcloj">http://www.pragprog.com/titles/shcloj</a></h1>
<div style="width: 285px; margin-left: auto; margin-right: auto;">
<img src="images/shcloj.jpg" width="285px"/>
</div>

</div>
</div> <!-- presentation -->
</body>
</html>
