<html>

<head>
	
	<title>clojure for ruby programmers</title>

<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<!-- style sheet links -->
<link rel="stylesheet" href="clojure-for-ruby-programmers.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="s6/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="s6/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="s6/code-highlighter.css" type="text/css"/>

<!-- S6 JS -->
<script src="s6/jquery.js" type="text/javascript"></script>
<script src="s6/slides.js" type="text/javascript"></script>
<script src="s6/code-highlighter.js" type="text/javascript"></script>
<script src="s6/clojure.js" type="text/javascript"></script>
<script src="s6/javascript.js" type="text/javascript"></script>
<script src="s6/ruby.js" type="text/javascript"></script>

</head>
<body>

<div class="layout">
  
  <div class="background">  
    <object data="clojure-for-ruby-programmers.svg" width="100%" height="100%">
		</object>
  </div>   
  
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1></h1>
<h2></h2>
</div>

      <div id='microsoft'>       
        <p>
          Microsoft's Internet Explorer browser
            has no built-in vector graphics machinery
             required for "loss-free" gradient background themes.
        </p>        
        <p>
          Please upgrade to a better browser
           such as <a href='http://getfirefox.com'>Firefox</a>, <a href='http://www.opera.com/download'>Opera</a>,
            <a href='http://apple.com/safari/download'>Safari</a> or others
            with built-in vector graphics machinery and much more.
          
          (Learn more or post questions or comments
              at the <a href='http://slideshow.rubyforge.org'>Slide Show (S9)</a>
            project site. Thanks!)
        </p>             
    </div>
</div>

<div class="presentation">
<div class='slide'>

<h1>clojure for ruby programmers</h1>
<ul>
	<li>stuart halloway</li>
	<li>stu@thinkrelevance.com</li>
</ul>


</div><div class='slide'>

<h1 class="center">quick start</h1>


</div><div class='slide'>

<h1 class="center">interactive environment</h1>
<h2 class="ruby-fg">irb</h2>
<h2 class="clojure-fg">REPL</h2>


</div><div class='slide'>

<h1 class="center">collections</h1>
<h2 class="ruby-fg">enumerable</h2>
<h2 class="clojure-fg">sequence</h2>


</div><div class='slide'>

<h1>select / filter</h1>
<pre>
<code class="ruby">(1..10).select {|i| i % 2 == 0}
=&gt; [2, 4, 6, 8, 10]
</code>
</pre>

<pre>
<code class="clojure">(filter (fn [i] (zero? (rem i 2))) (range 1 11))
-&gt; (2 4 6 8 10)
</code>
</pre>


</div><div class='slide'>

<h1>map / map</h1>
<pre>
<code class="ruby">(1..10).map {|i| i * 2}
=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</code>
</pre>

<pre>
<code class="clojure">(map #(* % 2) (range 1 11))
-&gt; (2 4 6 8 10 12 14 16 18 20)
</code>
</pre>


</div><div class='slide'>

<h1>inject / reduce</h1>
<pre>
<code class="ruby">(1..10).inject {|acc,i| acc + i}
=&gt; 55
</code>
</pre>

<pre>
<code class="clojure">(reduce + (range 1 11))
-&gt; 55
</code>
</pre>


</div><div class='slide'>

<h1>infix vs. prefix</h1>
<pre>
<code class="ruby">1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
=&gt; 55
</code>
</pre>

<pre>
<code class="clojure">(apply + (range 11))
-&gt; 55
</code>
</pre>


</div><div class='slide'>

<h1>higher-order functions</h1>
<pre>
<code class="ruby">def make_adder(x)
  lambda {|i| x + i}
end

adder = make_adder(3)
adder[4]
=&gt; 7
</code>
</pre>

<pre>
<code class="clojure">(defn make-adder [x] (fn [i] (+ i x)))
-&gt; #'user/make-adder

(def adder (make-adder 3))
-&gt; #'user/adder

(adder 4)
-&gt; 7
</code>
</pre>


</div><div class='slide'>

<h1 class="center">why clojure?</h1>


</div><div class='slide'>

<h1 class="center">1. elegance</h1>


</div><div class='slide'>

<h1 class="center">2. sequence library</h1>


</div><div class='slide'>

<h1 class="center">3. functional programming</h1>


</div><div class='slide'>

<h1 class="center">4. concurrency</h1>


</div><div class='slide'>

<h1 class="center">5. macros</h1>


</div><div class='slide'>

<h1 class="center">6. java interop</h1>


</div><div class='slide'>

<h1>data structures</h1>
<table>
<thead>
    <th class="ruby-bg" colspan="2">ruby</th>
    <th class="clojure-bg" colspan="2">clojure</th>
</thead>
<tr>
    <td>array</td>
    <td><code language="ruby">[1, 2, 3]</code></td>
    <td>vector</td>
    <td><code language="clojure">[1 2 3]</code></td>
</tr>
<tr>
    <td>hash</td>
    <td><code class="ruby">{:name =&gt; "Ruby", :creator =&gt; "Matz"}</code></td>
    <td>map</td>
    <td><code class="clojure">{:name "Clojure" :creator "Hickey"}</code></td>
</tr>
<tr>
    <td>set</td>
    <td><code class="ruby">Set[1,2,3]</code></td>
    <td>set</td>
    <td><code class="clojure">#{1 2 3}</code></td>
</tr>
</table>


</div><div class='slide'>

<h1>comments are whitespace</h1>
<pre>
<code class="clojure">(= [1 2 3] [1, 2, 3])
-&gt; true

,(,=, [1,, 2 3] [1, 2, 3],,,,)
-&gt; true
</code>
</pre>


</div><div class='slide'>

<h1 class="center">IFn</h1>


</div><div class='slide'>

<h1>IFn example: maps</h1>
<pre>
<code class="clojure">(def lang {:name "Clojure" :creator "Hickey"})
#'user/lang

(get lang :name)
-&gt; "Clojure"

(lang :name)
-&gt; "Clojure"

(:name lang)
-&gt; "Clojure"
</code>
</pre>


</div><div class='slide'>

<h1 class="center">multiple binding</h1>
<h2 class="ruby-fg">parallel assignment</h2>
<h2 class="clojure-fg">destructuring</h2>


</div><div class='slide'>

<h1>multiple binding example 1</h1>
<pre>
<code class="ruby">x, y, z = [1, 2, 3]
"x: #{x} y: #{y} z: #{z}"
=&gt; "x: 1 y: 2 z: 3"
</code>
</pre>

<pre>
<code class="clojure">(let [[x y z] [1 2 3]]
  (format "x: %d y: %d z: %d" x y z))
-&gt; "x: 1 y: 2 z: 3"
</code>
</pre>


</div><div class='slide'>

<h1>multiple binding example 2</h1>
<pre>
<code class="clojure">(let [[_ _ z :as point] [-14 11 21]]
  (format "z: %d in %d dimensions" z (count point)))
-&gt; "z: 21 in 3 dimensions"
</code>
</pre>


</div><div class='slide'>

<h1 class="center">metadata</h1>


</div><div class='slide'>

<h1>metdata on a var</h1>
<pre>
<code class="clojure">-&gt; #'format
#'clojure.core/format

-&gt; ^#'format
{:ns #&lt;Namespace clojure.core&gt;, 
 :name format, 
 :file "core.clj", 
 :line 3341, 
 :arglists ([fmt &amp; args]), 
 :tag java.lang.String, 
 :doc "Formats a string using java.lang.String.format, see\
java.util.Formatter for format\n  string syntax"}
</code>
</pre>


</div><div class='slide'>

<h1 class="center">2. sequence library</h1>


</div><div class='slide'>

<h1 class="center">what is a sequence?</h1>


</div><div class='slide'>

<h1>first / rest / cons</h1>
<pre> 
<code class="clojure">(first [1 2 3])
-&gt; 1

(rest [1 2 3])
-&gt; (2 3)

(cons "hello" [1 2 3])
-&gt; ("hello" 1 2 3) 
</code> </pre>


</div><div class='slide'>

<h1>sequence library examples</h1>
<pre>
<code class="clojure">(iterate inc 1)
-&gt; (1 2 3 4 5 ...)

(repeat :foo)
-&gt; (:foo :foo :foo :foo :foo ...)

(cycle [1 2])
-&gt; (1 2 1 2 1 ...)

(interleave "ABCDE" (range 5))
-&gt; (\A 0 \B 1 \C 2 \D 3 \E 4)
</code> 
</pre>


</div><div class='slide'>

<h1 class="center">sequence comprehension</h1>


</div><div class='slide'>

<h1>sequence comprehension example</h1>
<pre> 
<code class="clojure">(for [file "ABCDEFGH" rank (range 1 9)] (str file rank))
-&gt; ("A1" "A2" "A3" "A4" "A5" ...) 

(for [i (iterate inc 0) :when (= 1 (rem i 2))] i)
-&gt; (1 3 5 7 9 ...)
</code> 
</pre>


</div><div class='slide'>

<h1 class="center">seq-ables</h1>


</div><div class='slide'>

<h1>seq-able examples</h1>
<pre> 
<code class="clojure">(map #(.getName %) (.listFiles (java.io.File. ".")))
-&gt; (".git" "build" "clojure-for-ruby-programmers.maruku" 
    "footer.html.erb" "gradient.svg.erb" ...) 

(line-seq (reader (java.io.File. "rakefile")))
-&gt; ("desc \"build the slideshow\"" 
     "" 
     "task :slideshow do" 
     "  sh \"slideshow -v -o build clojure-for-ruby-programmers.maruku\"" 
     "end" ...)
</code> 
</pre>


</div><div class='slide'>

<h1 class="center">3. functional programming</h1>


</div><div class='slide'>

<h1 class="center">a. pure functions</h1>


</div><div class='slide'>

<h1 class="center">b. referential transparency</h1>


</div><div class='slide'>

<h1 class="center">c. immutability</h1>


</div><div class='slide'>

<h1 class="center">what about memory usage?!?</h1>


</div><div class='slide'>

<h1 class="center">d. shared structure</h1>


</div><div class='slide'>

<h1>shared structure example</h1>

<pre> 
<code class="clojure">(def a '(1 2))
-&gt; #'user/a

(def b (cons 0 a))
-&gt; #'user/b
</code>
</pre>
<p><img src="images/shared-structure.jpg"/></p>


</div><div class='slide'>

<h1>functional style</h1>


</div><div class='slide'>

<h1 class="center">recur</h1>


</div><div class='slide'>

<h1>recur example</h1>
<pre> 
<code class="clojure">; from stactrace.clj, by Stuart Sierra
(defn print-cause-trace
  "Like print-stack-trace but prints chained exceptions (causes)."
  ([tr] (print-cause-trace tr nil))
  ([tr n]
     (print-stack-trace tr n)
     (when-let [cause (.getCause tr)]
       (print "Caused by: " )
       (recur cause n))))
</code> 
</pre>


</div><div class='slide'>

<h1 class="center">laziness</h1>


</div><div class='slide'>

<h1>laziness, circa jan 2009</h1>

<pre>
<code class="clojure">(defn lazy-cons-fibo []
  ((fn fib [a b] 
     (lazy-cons a (fib b (+ a b)))) 
   0 1)) 
</code> 
</pre>


</div><div class='slide'>

<h1>laziness, feb 17, 2009</h1>
<ul>
	<li><a href="http://groups.google.com/group/clojure/browse_frm/thread/ead08a78c5dbb9bd">Clojure is fully lazy!</a></li>
</ul>


</div><div class='slide'>

<h1 class="center">realization</h1>


</div><div class='slide'>

<h1>realization example</h1>
<pre> 
<code class="clojure">(drop 1000000000 (iterate inc 0))
; ...wait for it...
-&gt; (1000000000 1000000001 1000000002 1000000003 1000000004 ...)
</code> 
</pre>


</div><div class='slide'>

<h1 class="center">memoization</h1>


</div><div class='slide'>

<h1>memoization example</h1>
<pre> 
<code class="clojure">; Hofstadter's Male and Female Sequences from GEB
; See http://en.wikipedia.org/wiki/Hofstadter_sequence
(declare m f)
(defn- m [n]
  (if (= n 0)
    0
    (- n (f (m (dec n))))))

(defn- f [n]		 
  (if (= n 0)
    1
    (- n (m (f (dec n))))))

(def m (memoize m))
(def f (memoize f))
</code>
</pre>


</div><div class='slide'>

<h1>game break!</h1>


</div><div class='slide'>

<h1>snake game</h1>
<pre>
<code class="clojure">
; Inspired by the snakes that have gone before:
; Abhishek Reddy's snake: http://www.plt1.com/1070/even-smaller-snake/
; Mark Volkmann's snake: http://www.ociweb.com/mark/programming/ClojureSnake.html 

(ns examples.snake
  (:import (java.awt Color Dimension) 
	   (javax.swing JPanel JFrame Timer JOptionPane)
           (java.awt.event ActionListener KeyListener))
  (:use clojure.contrib.import-static
	[clojure.contrib.seq-utils :only (includes?)]))
(import-static java.awt.event.KeyEvent VK_LEFT VK_RIGHT VK_UP VK_DOWN)

; ----------------------------------------------------------
; functional model
; ----------------------------------------------------------
(def width 75)
(def height 50)
(def point-size 10)
(def turn-millis 75)
(def win-length 5)
(def dirs { VK_LEFT  [-1  0] 
            VK_RIGHT [ 1  0]
            VK_UP    [ 0 -1] 
	    VK_DOWN  [ 0  1]})

(defn add-points [&amp; pts] 
  (vec (apply map + pts)))

(defn point-to-screen-rect [pt] 
  (map #(* point-size %) 
       [(pt 0) (pt 1) 1 1]))

(defn create-apple [] 
  {:location [(rand-int width) (rand-int height)]
   :color (Color. 210 50 90)
   :type :apple}) 

(defn create-snake []
  {:body (list [1 1]) 
   :dir [1 0]
   :type :snake
   :color (Color. 15 160 70)})

(defn move [{:keys [body dir] :as snake} &amp; grow]
  (assoc snake :body (cons (add-points (first body) dir) 
			   (if grow body (butlast body)))))

(defn turn [snake newdir] 
  (if newdir (assoc snake :dir newdir) snake))

(defn win? [{body :body}]
  (&gt;= (count body) win-length))

(defn head-overlaps-body? [{[head &amp; body] :body}]
  (includes? body head))

(def lose? head-overlaps-body?)

(defn eats? [{[snake-head] :body} {apple :location}]
   (= snake-head apple))

; ----------------------------------------------------------
; mutable model
; ----------------------------------------------------------
(defn update-positions [snake apple]
  (dosync
   (if (eats? @snake @apple)
     (do (ref-set apple (create-apple))
	 (alter snake move :grow))
     (alter snake move)))
  nil)

(defn update-direction [snake newdir]
  (dosync (alter snake turn newdir)))

(defn reset-game [snake apple]
  (dosync (ref-set apple (create-apple))
	  (ref-set snake (create-snake)))
  nil)

; ----------------------------------------------------------
; gui
; ----------------------------------------------------------
(defn fill-point [g pt color] 
  (let [[x y width height] (point-to-screen-rect pt)]
    (.setColor g color) 
    (.fillRect g x y width height)))

(defmulti paint (fn [g object &amp; _] (:type object)))

(defmethod paint :apple [g {:keys [location color]}] 
  (fill-point g location color))

(defmethod paint :snake [g {:keys [body color]}] 
  (doseq [point body]
    (fill-point g point color)))

(defn game-panel [frame snake apple]
  (proxy [JPanel ActionListener KeyListener] []
    (paintComponent [g] 
      (proxy-super paintComponent g)
      (paint g @snake)
      (paint g @apple))
    (actionPerformed [e] 
      (update-positions snake apple)
      (when (lose? @snake)
	(reset-game snake apple)
	(JOptionPane/showMessageDialog frame "You lose!"))
      (when (win? @snake)
	(reset-game snake apple)
	(JOptionPane/showMessageDialog frame "You win!"))
      (.repaint this))
    (keyPressed [e] 
      (update-direction snake (dirs (.getKeyCode e))))
    (getPreferredSize [] 
      (Dimension. (* (inc width) point-size) 
		  (* (inc height) point-size)))
    (keyReleased [e])
    (keyTyped [e])))

(defn game [] 
  (let [snake (ref (create-snake)) 
	apple (ref (create-apple))
	frame (JFrame. "Snake")
	panel (game-panel frame snake apple)
	timer (Timer. turn-millis panel)]
    (doto panel
      (.setFocusable true)
      (.addKeyListener panel))
    (doto frame
      (.add panel)
      (.pack)
      (.setVisible true))
    (.start timer) 
    [snake, apple, timer]))
</code>
</pre>


</div><div class='slide'>

<h1 class="center">4. concurrency</h1>


</div><div class='slide'>

<h1 class="center">software transactional memory</h1>


</div><div class='slide'>

<h1>STM example</h1>
<pre>
<code class="clojure">; pure function
(defn turn [snake newdir] 
  (if newdir (assoc snake :dir newdir) snake))

; compose mutability atop pure functions
(defn update-direction [snake newdir]
  (dosync (alter snake turn newdir)))
</code>
</pre>


</div><div class='slide'>

<h1>STM Benefits</h1>
<ul>
	<li>Compose atop pure functional code</li>
	<li>Easy to use (compare locks!)</li>
</ul>


</div><div class='slide'>

<h1 class="center">lots more to say</h1>
<h2 class="center">(come to the concurrency talk)</h1>


</div><div class='slide'>

<h1 class="center">mapping OO concepts to FP</h1>


</div><div class='slide'>

<h1>what is OO?</h1>
<ul>
	<li>Encapsulation</li>
	<li>Polymorphism</li>
	<li><span class="stricken">Inheritance</span></li>
	<li>Reuse</li>
</ul>


</div><div class='slide'>

<h1>encapsulation example</h1>
<pre> 
<code class="clojure">(defn game [] 
  (let [snake (ref (create-snake)) 
	apple (ref (create-apple))
	frame (JFrame. "Snake")
	panel (game-panel frame snake apple)
	timer (Timer. turn-millis panel)]
    (doto panel
      (.setFocusable true)
      (.addKeyListener panel))
    (doto frame
      (.add panel)
      (.pack)
      (.setVisible true))
    (.start timer) 
    [snake, apple, timer]))
</code>
</pre>


</div><div class='slide'>

<h1 class="center">polymorphism is the flatland of multimethods</h1>


</div><div class='slide'>

<h1>multimethod example 1</h1>
<ul>
	<li>polymorphism</li>
</ul>
<pre>
<code class="clojure">; vastly simplified from Clojure's own print mechanism
(defmulti my-print class)

(defmethod my-print String [s]
  (.write *out* s))

(defmethod my-print nil [s]
  (.write *out* "nil"))

(defmethod my-print Number [n]
  (.write *out* (.toString n)))

(defmethod my-print :default [s]
  (.write *out* "#&lt;")
  (.write *out* (.toString s))
  (.write *out* "&gt;"))
</code>
</pre>


</div><div class='slide'>

<h1>multimethod example 2</h1>
<ul>
	<li>dispatch on multiple facets of a single object</li>
</ul>
<pre>
<code class="clojure">(derive ::Savings ::Account)
(derive ::Checking ::Account)

(defmulti service-charge (fn [acct] [(account-level acct) (:tag acct)]))
(defmethod service-charge [::Basic ::Checking]   [_] 25)
(defmethod service-charge [::Basic ::Savings]    [_] 10)
(defmethod service-charge [::Premium ::Account] [_] 0)
</code>
</pre>


</div><div class='slide'>

<h1>multimethod example 3</h1>
<ul>
	<li>dispatch on multiple objects</li>
</ul>
<pre>
<code class="clojure">(defmulti coerce 
  (fn [dest-class src-inst] [dest-class (class src-inst)]))

(defmethod coerce [java.io.File String] [_ str] 
  (java.io.File. str))

(defmethod coerce [Boolean/TYPE String] [_ str]
  (contains? #{"on" "yes" "true"} (.toLowerCase str)))

(defmethod coerce :default [dest-cls obj] (cast dest-cls obj))
</code>
</pre>


</div><div class='slide'>

<h1>reuse example?</h1>
<ul>
	<li>Everything!</li>
	<li>Try to find a reuse <strong>counterexample</strong>!</li>
</ul>


</div><div class='slide'>

<h1 class="center">5. macros</h1>
<h2 class="center">(come to the macro talk)</h1>


</div><div class='slide'>

<h1 class="center">6. java interop</h1>


</div><div class='slide'>

<h1>interop forms</h1>
<table>
<thead>
    <th>java</th>
    <th>clojure</th>
    <th>sugared</th>
</thead>
<tr>
    <td><code class="clojure">new Widget("red")</code></td> 
    <td><code class="clojure">(new Widget "red")</code></td> 
    <td><code class="clojure">(Widget. "red")</code></td> 
</tr>
<tr>
    <td><code class="clojure">Math.PI</code></td> 
    <td><code class="clojure">(. Math PI)</code></td> 
    <td><code class="clojure">Math/PI</code></td> 
</tr>
<tr>
    <td><code class="clojure">System.currentTimeMillis()</code></td> 
    <td><code class="clojure">(. System currentTimeMillis)</code></td> 
    <td><code class="clojure">(System/currentTimeMillis)</code></td> 
</tr>
<tr>
    <td><code class="clojure">rnd.nextInt()</code></td> 
    <td><code class="clojure">(. rnd nextInt)</code></td> 
    <td><code class="clojure">(.nextInt rnd)</code></td> 
</tr>
<tr>
    <td><code class="clojure">person.getAddress().getZipCode()</code></td> 
    <td><code class="clojure">(. (. person getAddress) getZipCode)</code></td> 
    <td><code class="clojure">(.. person getAddress getZipCode)</code></td> 
</tr>
</table>


</div><div class='slide'>

<h1 class="center">ruby inspired libraries</h1>


</div><div class='slide'>

<h1 class="center">compojure</h1>


</div><div class='slide'>

<h1>compojure example: servlet</h1>
<pre>
<code class="clojure">(defservlet snippet-servlet
  (GET "/" 
     (new-snippet))

  (GET "/:id"
     (show-snippet (route :id)))

  (POST "/"
    (create-snippet (:body params))))	
</code> 
</pre>


</div><div class='slide'>

<h1>compojure example: handlers</h1>
<pre>
<code class="clojure">(defn new-snippet []
  (layout "Create a Snippet"
    (form-to [POST "/"]
      (text-area {:rows 20 :cols 73} "body")
      [:br]
      (submit-button "Save"))))

(defn create-snippet [body]
  (if-let [id (insert-snippet body)]
    (redirect-to (str "/" id))
    (redirect-to "/")))
</code> 
</pre>


</div><div class='slide'>

<h1 class="center">clj-record</h1>


</div><div class='slide'>

<h1>clj-record example</h1>
<pre>
<code class="clojure">(cljrec/init-model
  (has-many products)
  (validates name "empty!" #(not (empty? %)))
  (validates name "starts with whitespace!"
    #(not (re-find #"^\s" %)))
  (validates name "ends with whitespace!" 
    #(not (re-find #"\s$" %)))
  (validates grade "negative!" 
    #(or (nil? %) (&gt;= % 0))))
</code> 
</pre>


</div><div class='slide'>

<h1>clojure&#8217;s strengths</h1>
<ul>
	<li>elegance</li>
	<li>sequence library</li>
	<li>functional programming</li>
	<li>concurrency model</li>
	<li>macros</li>
	<li>java interop</li>
</ul>


</div><div class='slide'>

<h1 class="center"><a href="http://www.pragprog.com/titles/shcloj">http://www.pragprog.com/titles/shcloj</a></h1>
<div style="width: 285px; margin-left: auto; margin-right: auto;">
<img src="images/shcloj.jpg" width="285px"/>
</div>

</div>
</div> <!-- presentation -->
</body>
</html>
