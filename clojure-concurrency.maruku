title: clojure concurrency

h1. clojure concurrency

* stuart halloway
* stu@thinkrelevance.com
* http://github.com/stuarthalloway/clojure-presentations

<h1 class="center">a tale of 5 concurrency models</h1>

<h1 class="center">1. refs</h1>

<h1 class="center">2. atoms</h1>

<h1 class="center">3. agents</h1>

<h1 class="center">4. dynamic vars</h1>

<h1 class="center">5. locking</h1>

<h1 class="center">game break!</h1>

<h1 class="center">1. references</h1>

h1. ref and deref

<pre>
<code class="clojure">
(def current-track (ref "Mars, the Bringer of War"))
-> #'user/current-track   

current-track
-> #<Ref clojure.lang.Ref@6fe2479>    

(deref current-track)
-> "Mars, the Bringer of War"

@current-track
-> "Mars, the Bringer of War"    
</code>
</pre>

h1. updates require a transaction

<pre>
<code class="clojure">
(ref-set current-track "Venus, the Bringer of Peace")
-> java.lang.IllegalStateException: No transaction running 
</code>
</pre>

h1. dosync scopes a transaction

<pre> 
<code class="clojure">
(dosync (ref-set current-track "Venus, the Bringer of Peace"))
"Venus, the Bringer of Peace"    
</code>
</pre>

<h1 class="center">alter</h1>

<pre>
<code class="clojure">
clojure.core/alter
([ref fun & args])
  Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.
</code>
</pre>

h1. alter example

<pre>
<code class="clojure">
(defstruct message :sender :text)
(def messages (ref ()))

(defn add-message [msg]
  (dosync (alter messages conj msg)))
</code>
</pre>

h1. ACID properties

* atomic
* consistent
* isolated
* durable

<h1 class="center">clojure STM provides ACI (not D)</h1>

h1. consistency via validators

<pre>
<code class="clojure">
(defn validate-message-list [lst]
  (if (not-every? #(and (:sender %) (:text %)) lst)
    (throw (IllegalStateException. "Not a valid message"))
    true))

(def messages (ref () :validator validate-message-list))
</code>
</pre>

h1. atomicity and isolation

* (MVCC) multiversion concurrency control

h1. how MVCC works

* tx begins by taking a *point*
* tx works against in-transaction-value
* if another (post-point) tx write collides, retry
* tx commit takes another point 

h1. ref-set and alter cause collisions

* what if you don't care about collisions?
* your update must be *commutative*
* use <code>commute</code> instead

h1. commute example

<pre>
<code class="clojure">
(defn add-message-commute [msg]
  (dosync (commute messages conj msg)))
</code>
</pre>

h1. prefer alter

* <code>commute</code> is an optimization
* <code>alter</code> will always work in place of <code>commute</code>
* the reverse is *not* true!

<h1 class="center">2. atoms</h1>

h1. why atoms?

* refs imply coordination
* or the possibility of future coordination
* what if you have just one bit of state?

h1. atom api parallels ref api

<table>
  <thead>
    <th>function</th>
    <th>ref api</th>
    <th>atom api</th>
  </thead>
  <tr>
    <td>create</td>
    <td><code>ref</code></td>
    <td><code>atom</code></td>
  </tr>
  <tr>
    <td>deref</td>
    <td><code>deref</code>/<code>@</code></td>
    <td><code>deref</code>/<code>@</code></td>
  </tr>
  <tr>
    <td>update</td>
    <td><code>alter</code></td>
    <td><code>swap!</code></td>
  </tr>
  <tr>
    <td>set</td>
    <td><code>ref-set</code></td>
    <td><code>reset!</code></td>
  </tr>
</table>

h1. atom example

<pre>
<code class="clojure">
; from clojure core
(defn memoize
  [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
</code>
</pre>

<h1 class="center">3. agents</h1>

h1. Why agents

* refs provide coordinated synchronous updates
* atoms provide uncoordinated synchronous updates
* agents provide *asynchronous* updates

<h1 class="center">unified update model</h1>

h1. update functions

<table>
  <thead>
    <th>Update Mechanism</th>
    <th>Refs</th>
    <th>Atoms</th>
    <th>Agents</th>
  </thead>
  <tr>
    <td>pure function application</td>
    <td><code>alter</code></td>
    <td><code>swap!</code></td>
    <td><code>send</code></td>
  </tr>
  <tr>
    <td>pure function (commutative)</td>
    <td><code>commute</code></td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>pure function (blocking)</td>
    <td>N/A</td>
    <td>N/A</td>
    <td><code>send-off</code></td>
  </tr>
  <tr>
    <td>setter</td>
    <td><code>ref-set</code></td>
    <td><code>reset!</code></td>
    <td>N/A</td>
  </tr>
</table>

h1. agent example

<pre>
<code class="clojure">
(defn add-message-with-backup [msg]
  (dosync 
   (let [snapshot (commute messages conj msg)]
     (send-off backup-agent (fn [filename]
			      (spit filename snapshot)
			      filename))
     snapshot)))
</code>
</pre>

<h1 class="center">4. dynamic vars</h1>

h1. vars can be set and dynamically bound

* use <code>set</code> for control flags
* use <code>binding</code> to make a temporary change
* name vars intended for binding like `*out*`

h1. set/binding example

<pre>
<code class="clojure">
(set! *print-length* 5)
-> 5

(range 20)
-> (0 1 2 3 4 ...)

(binding [*print-length* 10] (range 20))
-> (0 1 2 3 4 ...)

(binding [*print-length* 10] (pr (range 20)))
-> (0 1 2 3 4 5 6 7 8 9 ...)
</code>
</pre>

h1. binding example

<pre>
<code class="clojure">
(use 'clojure.contrib.shell-out)
(def foo
  (with-out-str
    (println [1 2 3])
    (println #{:A :B :C})))

(print foo)
[1 2 3]
#{:A :B :C}  
</code>
</pre>

<h1 class="center">5. locking</h1>

h1. locking example

<pre>
<code class="clojure">
; from lancet
(defn runonce
  [function] 
  (let [sentinel (Object.)
	result (atom sentinel)
	reset-fn (fn [] (reset! result sentinel))
	has-run-fn (fn [] (not= @result sentinel))]
    [has-run-fn
     reset-fn
     (fn [& args]
       (locking sentinel
	 (if (= @result sentinel)
	   (reset! result (function))
	   @result)))]))
</code>
</pre>

<h1 class="center" style="font-size: 30pt;"><a href="http://www.pragprog.com/titles/shcloj">http://www.pragprog.com/titles/shcloj</a></h1>

<div style="width: 285px; margin-left: auto; margin-right: auto;">
  <img src="images/shcloj.jpg" width="285px"/>
</div>
