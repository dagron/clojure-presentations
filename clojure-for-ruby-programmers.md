h1. Clojure for Java Programmers

* Stuart Halloway
* stu@thinkrelevance.com

h1. Why Clojure?

<code class="clojure">
(let [the stuff]
  (print "foo"))
</code>

h1. Elegance

h1. Sequence Library

h1. Functional Programming

h1. Concurrency

h1. Java Interop

h1. Quick Start

h1. Interactive Environment 

<h2 class="ruby-concept">irb</h2>

<h2 class="clojure-concept">REPL</h2>

h1. Collections

<h2 class="ruby-concept">Enumerable</h2>

<h2 class="clojure-concept">Sequence</h2>

h1. Higher-Order Functions

h1. Function Arguments

<h2 class="ruby-concept">Blocks</h2>

<h2 class="clojure-concept">Anonymous Functions</h2>

h1. Data Structures

h1. Names

<h2 class="ruby-concept">Symbols</h2>

<h2 class="clojure-concept">Symbols, Keywords</h2>

h1. IFn

h1. Multiple-Binding

<h2 class="ruby-concept">Parallel Assignment</h2>

<h2 class="clojure-concept">Destructuring</h2>

h1. Metadata

h1. The Sequence Library

h1. Reduce

h1. Sequence Comprehensions

h1. Seq-ables

h1. Lazy and Infinite

h1. Realization

h1. Functional Programming

h1. Pure Functions

h1. Referential Transparency

h1. Immutability

h1. Shared Structure

h1. Recurrences

h1. recur

h1. Laziness

h1. Memoization

h1. Concurrency

h1. Software Transactional Memory

h1. Unified Update Model

h1. Example: Snake Game

h1. How do I do OO?

h1. What is OO?

* Encapsulation
* Polymorphism
* <span class="stricken">Inheritance</span>Reuse

h1. Macros

h1. Java Interop

h1. Interop Forms

h1. Threading

(Not the concurrency kind)

h1. Ruby Inspired Libraries

h1. Compojure

h1. clj-record

h1. Clojure's Strengths

* Elegance Throughout
* Sequence Library
* Functional Programming
* Concurrency Model
* Macros
* Java Interop

h1. The Book

[http://www.pragprog.com/titles/shcloj/programming-clojure](http://www.pragprog.com/titles/shcloj/programming-clojure)
